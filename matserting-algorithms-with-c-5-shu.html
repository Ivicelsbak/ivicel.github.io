<!DOCTYPE html>
<html lang="zh" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Matserting Algorithms with C-5: 树 - Take Thoughts</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="./matserting-algorithms-with-c-5-shu.html">

        <meta name="author" content="ivicel" />
        <meta name="keywords" content="算法,C,集合,数据结构" />
        <meta name="description" content="二叉树(Binary tree) 先序遍历: 根结点-&gt;左子结点-&gt;右子结点 中序遍历: 左子结点-&gt;根结点-&gt;右子结点 后序遍历: 左子结点-&gt;右子结点-&gt;根结占 层级遍历: 树根结点-&gt;下层左结点-&gt;该层右结点 (广度优先方法) 树的平衡是指在添加结点到下一层是必须保证本层的结点是满额的 二叉的接口定义 /* 这里不没包含插入和删除非叶子结点的操作, 这些操作需要根据具体的应用将树中的其他结点做相应的调整 */ /* bitree.h */ #ifndef BITREE_H #define BITREE_H #include &lt;stdlib.h&gt; /* 节点结构 */ typedef struct BiTreeNode_ { void *data; /* 左结点 */ struct BiTreeNode_ *left; /* 右结点 */ struct BiTreeNode_ *right; }BiTreeNode; /* 二叉树结构 */ typedef …" />

        <meta property="og:site_name" content="Take Thoughts" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Matserting Algorithms with C-5: 树"/>
        <meta property="og:url" content="./matserting-algorithms-with-c-5-shu.html"/>
        <meta property="og:description" content="二叉树(Binary tree) 先序遍历: 根结点-&gt;左子结点-&gt;右子结点 中序遍历: 左子结点-&gt;根结点-&gt;右子结点 后序遍历: 左子结点-&gt;右子结点-&gt;根结占 层级遍历: 树根结点-&gt;下层左结点-&gt;该层右结点 (广度优先方法) 树的平衡是指在添加结点到下一层是必须保证本层的结点是满额的 二叉的接口定义 /* 这里不没包含插入和删除非叶子结点的操作, 这些操作需要根据具体的应用将树中的其他结点做相应的调整 */ /* bitree.h */ #ifndef BITREE_H #define BITREE_H #include &lt;stdlib.h&gt; /* 节点结构 */ typedef struct BiTreeNode_ { void *data; /* 左结点 */ struct BiTreeNode_ *left; /* 右结点 */ struct BiTreeNode_ *right; }BiTreeNode; /* 二叉树结构 */ typedef …"/>
        <meta property="article:published_time" content="2017-03-27" />
            <meta property="article:section" content="Data Structure Algorithms" />
            <meta property="article:tag" content="算法" />
            <meta property="article:tag" content="C" />
            <meta property="article:tag" content="集合" />
            <meta property="article:tag" content="数据结构" />
            <meta property="article:author" content="ivicel" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css"/>
    <link href="./theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="./theme/css/pygments/default.css" rel="stylesheet">
    <link rel="stylesheet" href="./theme/css/style.css" type="text/css"/>





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="./" class="navbar-brand">
Take Thoughts            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="./category/c-language.html">C language</a>
                        </li>
                        <li class="active">
                            <a href="./category/data-structure-algorithms.html">Data structure algorithms</a>
                        </li>
                        <li >
                            <a href="./category/data-structure-and-algorithms.html">Data structure and algorithms</a>
                        </li>
                        <li >
                            <a href="./category/database.html">Database</a>
                        </li>
                        <li >
                            <a href="./category/javascript.html">Javascript</a>
                        </li>
                        <li >
                            <a href="./category/python.html">Python</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="./matserting-algorithms-with-c-5-shu.html"
                       rel="bookmark"
                       title="Permalink to Matserting Algorithms with C-5: 树">
                        Matserting Algorithms with C-5: 树
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2017-03-27T00:00:00+08:00"> Mon 27 March 2017</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="./tag/suan-fa.html">算法</a>
        /
	<a href="./tag/c.html">C</a>
        /
	<a href="./tag/ji-he.html">集合</a>
        /
	<a href="./tag/shu-ju-jie-gou.html">数据结构</a>
        
</footer><!-- /.post-info -->                    </div>
                </div>
                <h3 id="binary-tree">二叉树(Binary tree)</h3>
<p><img alt="二叉树" src="https://ivicel.github.io/images/二叉树.png" /></p>
<p><strong>先序遍历</strong>: 根结点-&gt;左子结点-&gt;右子结点</p>
<p><strong>中序遍历</strong>: 左子结点-&gt;根结点-&gt;右子结点</p>
<p><strong>后序遍历</strong>: 左子结点-&gt;右子结点-&gt;根结占</p>
<p><strong>层级遍历</strong>: 树根结点-&gt;下层左结点-&gt;该层右结点 (广度优先方法)</p>
<p><img alt="树的遍历方法" src="https://ivicel.github.io/images/树的遍历方法.png" /></p>
<blockquote>
<p>树的平衡是指在添加结点到下一层是必须保证本层的结点是满额的</p>
</blockquote>
<p>二叉的接口定义</p>
<div class="highlight"><pre><span></span><span class="cm">/* 这里不没包含插入和删除非叶子结点的操作, 这些操作需要根据具体的应用将树中的其他结点做相应的调整 */</span>
<span class="cm">/* bitree.h */</span>
<span class="cp">#ifndef BITREE_H</span>
<span class="cp">#define BITREE_H</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cm">/* 节点结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BiTreeNode_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 左结点 */</span>
    <span class="k">struct</span> <span class="n">BiTreeNode_</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="cm">/* 右结点 */</span>
    <span class="k">struct</span> <span class="n">BiTreeNode_</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span><span class="n">BiTreeNode</span><span class="p">;</span>

<span class="cm">/* 二叉树结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BiTree_</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="cm">/* 为二叉搜索树使用, 比较两结点的大小, key1&gt;key2 返回 1, 小于返回 -1, 相等返回 0 */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="p">}</span><span class="n">BiTree</span><span class="p">;</span>
<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">bitree_init</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">bitree_destroy</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">);</span>
<span class="cm">/* 插入左结点 */</span>
<span class="kt">void</span> <span class="nf">bitree_ins_left</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 插入右结点 */</span>
<span class="kt">void</span> <span class="nf">bitree_ins_right</span><span class="p">(</span><span class="n">biTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 删除结点以及其下层全部的子结点, 并未实现只删除任意结点而不删除子结点 */</span>
<span class="kt">void</span> <span class="nf">bitree_rem_left</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">bitree_rem_right</span><span class="p">(</span><span class="n">biTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="cm">/* 将两棵树合成新的二叉树, data 为根结点 */</span>
<span class="kt">int</span> <span class="nf">bitree_merge</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">merge</span><span class="p">,</span> <span class="n">BiTree</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">BiTree</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cp">#define bitree_size(tree) ((tree)-&gt;size)</span>
<span class="cp">#define bitree_root(tree) ((tree)-&gt;root)</span>
<span class="cp">#define bitree_is_eob(node) ((ndoe) == NULL)</span>
<span class="cp">#define bitree_is_leaf(node) ((node)-&gt;left == NULL &amp;&amp; (node)-&gt;rigth == NULL)</span>
<span class="cp">#define bitree_data(node) ((node)-&gt;data)</span>
<span class="cp">#define bitree_left(node) ((node)-&gt;left)</span>
<span class="cp">#define bitree_right(node) ((ndoe)-&gt;right)</span>

<span class="cp">#endif</span>
</pre></div>


<p>二叉树的实现 </p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bitree.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">bitree_init</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bitree_destroy</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bitree_rem_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BiTree</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bitree_ins_left</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">new_node</span><span class="p">,</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* node 为 NULL 并且树为空时, 作根结点 */</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 已有左结点 */</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="cm">/* 申请内存 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">new_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiTreeNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BiTreeNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bitree_ins_right</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">new_node</span><span class="p">,</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">new_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiTreeNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BiTreeNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_ndoe</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bitree_rem_left</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 传入 NULL 删除根结点 */</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 确定是否有左结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">position</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bitree_rem_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">bitree_rem_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">((</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bitree_rem_right</span><span class="p">(</span><span class="n">biTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>
    <span class="cm">/* 空树 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 传入 NULL 删除根结点下右结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 确认有右结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">position</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bitree_rem_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">biTree_rem_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">((</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bitree_merge</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">merge</span><span class="p">,</span> <span class="n">BiTree</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">BiTree</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bitree_init</span><span class="p">(</span><span class="n">merge</span><span class="p">,</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">);</span>
    <span class="cm">/* 设置新树根结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_ins_left</span><span class="p">(</span><span class="n">merge</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bitree_destroy</span><span class="p">(</span><span class="n">merge</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">bitree_root</span><span class="p">(</span><span class="n">merge</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">bitree_root</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
    <span class="n">bitree_root</span><span class="p">(</span><span class="n">merge</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">bitree_root</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
    <span class="cm">/* 合并后树的大小 */</span>
    <span class="n">merge</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">merge</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">bitree_size</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">bitree_size</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

    <span class="cm">/* 将原先的左, 右树结点的大小和根结点重置 */</span>
    <span class="n">left</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">left</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">right</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">right</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>遍历二叉树的实现</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bitree.h&quot;</span><span class="cp"></span>
<span class="cm">/* 前序遍历 */</span>
<span class="kt">int</span> <span class="nf">preorder</span><span class="p">(</span><span class="k">const</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 非空结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 将数据加入到列表尾部 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 递归左结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 递归右结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 中序遍历 */</span>
<span class="kt">int</span> <span class="nf">inorder</span><span class="p">(</span><span class="k">const</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 非 NULL 结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 查找左结点, 如果存在递归到末尾叶子结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 将结点加到队列中 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 查找右结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 后序遍历 */</span>
<span class="kt">int</span> <span class="nf">postorder</span><span class="p">(</span><span class="k">const</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 非空结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 先递归左结点, 将左结点加入到队列中 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 再递归右结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 结点加入到队列 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3 id="_1">二叉搜索树</h3>
<p>二叉搜索树中, 左结点总比根小, 右结点总比根大</p>
<p>在二叉搜索树中查询一个结点, 从根结点开始, 当遇到一个比目标结点值大的结点时, 顺着该结点的左结点查找; 如果遇到的结点小于目标结点时, 则顺着该结点的右子树查找, 一直查到叶子结点</p>
<p>只有当二叉搜索树保持平衡时其查找效率才是最高. 一种方法是将二叉树实现为 AVL树(Adel'son-Vel'skii and Landis)</p>
<p>AVL树是一种特殊类型的二叉树, 它的每个结点都保存一份额外信息--结点的平衡因子</p>
<p>结点的平衡因子 = 左子树高度 - 右子树高度</p>
<ul>
<li>+1 表示左倾斜(left-heavy)</li>
<li>-1 表示右倾斜(rigth-heavy)</li>
<li>0 表示平衡(left-heavy)</li>
</ul>
<p><img alt="AVL树" src="https://ivicel.github.io/images/AVL树.png" /></p>
<p>向 AVL树中插入一个结点时, 必须计算因为执行了插入操作对平衡因子带来的改; 其次, 如果任何平衡因子为变为了±2, 就必须从这个结点开始往下重新平衡这棵树, 重新平衡的过程称为旋转</p>
<p><strong>LL(left-left)旋转</strong></p>
<p>当 x 位于 A 的左子树下的左子树上, 执行 LL 旋转. 设 left 为 A 的左子树, 将 A 的左指针指向 left 的右结点, left 的右指针指向 A, 将原来指向 A 的指针改为指向 left, 旋转后, A 和 left 的平衡因子都改为 0</p>
<p><img alt="LL旋转" src="https://ivicel.github.io/images/LL旋转.png" /></p>
<p><strong>LR(left-right)旋转</strong></p>
<p>当 x 位于 A 的左子树下的右子树上时, 执行 LR 旋转. 设 left 是 A 的左子结点, A 的子孙结点 grandchild 为 left 的右子结点. 要执行 LR旋转, 将 left 的右子结点指向 grandchild 的左子结点, grandchild 的左子结点指向 left, A 的左子结点指向 grandchild 的右子结点, 再将 grandchild 的右子结点指向 A, 最后将原来指向 A 的指针指向 grandchild</p>
<p><img alt="LR旋转" src="https://ivicel.github.io/images/LR旋转.png" /></p>
<p>执行 LR 旋转后, 调整结点的平衡因子取决于旋转前 grandchild 结点的原平衡因子值</p>
<p>下方的图展示了 3 种需要考虑到的情况</p>
<p>如果 grandchild 结点的原始平衡因子为+1, 就将 A 的平衡因子设置为-1, 将 left 结点的平衡因子设置为 0</p>
<p>如果 grandchild 结点的原始平衡因子为 0, 就将 A 和 left 结点的平衡因为都设置为 0</p>
<p>如果 grandchild 结点的原始平衡因子为-1, 就将 A 的平衡因子设置为 0, 将 left 的平衡因为设置为+1</p>
<p><img alt="LR旋转后更新" src="https://ivicel.github.io/images/LR旋转后更新.png" /></p>
<p><strong>RR(right-right)旋转</strong></p>
<p>当 x 位于 A 的右子树下的右子树上时, 执行 RL 旋转. RR 旋转与 LL 旋转是对称关系. 设 A 的右结点为 right, 要执行 RR 旋转, 将 A 的右指针指向 right 的左子结点, right 的左指针指向 A, 原来指向 A 的指针修改为指向 right</p>
<p><strong>RL(right-left)旋转</strong></p>
<p>当 x 位于 A 的右子树下的左子树上的时, 执行 RL 旋转. RL 旋转与 LR 旋转是对称关系. 设 A 的右结点为 right, right 的左子结点为 grandchild. 要执行 RL 旋转, 将 right 结点的左子结点指向 grandchild 的右子结点, 将 grandchild 的右子结点指向 right, 将 A 的右子结点指向 grandchild 的左子结点, 将 grandchild 的左子结点指向 A, 最后将原来指向 A 的指针指向 grandchild</p>
<p>如果 grandchild 结点的原始平衡因子为+1, 就将 A 的平衡因子设置为 0, 将 right 结点的平衡因子设置为 -1</p>
<p>如果 grandchild 结点的原始平衡因子为 0, 就将 A 和 left 结点的平衡因为都设置为 0</p>
<p>如果 grandchild 结点的原始平衡因子为-1, 就将 A 的平衡因子设置为 +1, 将 right 的平衡因为设置为0</p>
<p>二叉搜索树头文件</p>
<div class="highlight"><pre><span></span><span class="cp">#ifndef BISTREE_H</span>
<span class="cp">#define BISTREE_H</span>

<span class="cp">#include</span> <span class="cpf">&quot;bitree.h&quot;</span><span class="cp"></span>

<span class="cp">#define AVL_LFT_HEAVY 1</span>
<span class="cp">#define AVL_BALANCED 0</span>
<span class="cp">#define AVL_RGT_HEAVY -1</span>

<span class="cm">/* AVL 树结点结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">AvlNode_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 销毁结点后, 指向的数据被未被销毁时设置结点为隐藏 */</span>
    <span class="kt">int</span> <span class="n">hidden</span><span class="p">;</span>
    <span class="cm">/* 平衡因子 */</span>
    <span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>
<span class="p">}</span><span class="n">AvlNode</span><span class="p">;</span>


<span class="k">typedef</span> <span class="n">BiTree</span> <span class="n">BisTree</span>

<span class="kt">void</span> <span class="nf">bistree_init</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="kt">void</span> <span class="nf">bistree_destroy</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bistree_insert</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bistree_remove</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bistree_lookup</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>

<span class="cp">#define bistree_size(tree) ((tree)-&gt;size)</span>

<span class="cp">#endif</span>
</pre></div>


<p>二叉搜索树实现</p>
<div class="highlight"><pre><span></span><span class="cm">/* bistree.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bistree.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_right</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="cm">/* 左旋转 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rotate_left</span><span class="p">(</span><span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">grandchild</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">==</span> <span class="n">AVL_LFT_HEAVY</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Perform an LL rotation */</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">grandchild</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">grandchild</span><span class="p">);</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">grandchild</span><span class="p">);</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">grandchild</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">AVL_LFT_HEAVY</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_RGT_HEAVY</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="nl">AVL_BALANCED</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="nl">AVL_RGT_HEAVY</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">left</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_LFT_HEAVY</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">grandchild</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">grandchild</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 右旋转 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rotate_right</span><span class="p">(</span><span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span> <span class="o">*</span><span class="n">grandchild</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">==</span> <span class="n">AVL_RGT_HEAVY</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* perform an RR rotation */</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* perform an RL rotation */</span>
        <span class="n">grandchild</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">grandchild</span><span class="p">);</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
        <span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">grandchild</span><span class="p">);</span>
        <span class="n">bitree_left</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">grandchild</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">AVL_LFT_HEAVY</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_RGT_HEAVY</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">AVL_BALANCED</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">AVL_RGT_HEAVY</span><span class="p">:</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_LFT_HEAVY</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">right</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">grandchild</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">grandchild</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_left</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>

    <span class="cm">/* do not allow destructionn of an empty tree */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* determine where to destroy nodes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* destroy the nodes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">position</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">destroy_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">destroy_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* call a user-defined function to free dynamically allocated data */</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* free the AVL data in the node, then free the node itself */</span>
        <span class="n">free</span><span class="p">((</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* adjust the size of the tree to account for the destroyed node */</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_right</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">position</span><span class="p">;</span>

    <span class="cm">/* do not allow destruction of an empty tree */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* determine where to destroy nodes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* destroy the nodes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">position</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">destroy_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="n">destroy_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">position</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* call a user-defined function to free dynamically allocated data */</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* free the AVL data in the node, then free the node itself */</span>
        <span class="n">free</span><span class="p">((</span><span class="o">*</span><span class="n">position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
        <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* adjust the size of the tree to account for the destroy node */</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">**</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">balanced</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AvlNode</span> <span class="o">*</span><span class="n">avl_data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cmpval</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

    <span class="cm">/* insert the data into the tree */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* handle insertion into an empty tree */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">avl_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AvlNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
        <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">bitree_ins_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">avl_data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* handle insertion into a tree that is not empty */</span>
        <span class="n">cmpval</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">compare</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* move to the left */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">avl_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AvlNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">bitree_ins_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">avl_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bitree_left</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">balanced</span><span class="p">))</span> 
                    <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* ensure that the tree remains balance */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">balanced</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="nl">AVL_LFT_HEAVY</span><span class="p">:</span>
                        <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                        <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="nl">AVL_BALANCED</span><span class="p">:</span>
                        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_LFT_HEAVY</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="nl">AVL_RGT_HEAVY</span><span class="p">:</span>
                        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                        <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="cm">/* if (cmpval &lt; 0) */</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* move to right */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">avl_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AvlNode</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">avl_data</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">bitree_ins_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">avl_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bitree_right</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">balanced</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* ensure that the tree remains balanced */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">balanced</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="nl">AVL_LFT_HEAVY</span><span class="p">:</span>
                        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_BALANCED</span><span class="p">;</span>
                        <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="nl">AVL_BALANCED</span><span class="p">:</span>
                        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="n">AVL_RGT_HEAVY</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="nl">AVL_RGT_HEAVY</span><span class="p">:</span>
                    <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                    <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="cm">/* if (cmpval &gt; 0) */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* handle finding a copy of the data */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">hidden</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* do nothing since the data is in the tree and not hidden */</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* insert the new data and mark it as not hidden */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* destroy the hidden data since it is being replaced */</span>
                    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
                <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="cm">/* do not rebalance because the tree structure is unchanged */</span>
                <span class="o">*</span><span class="n">balanced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">statice</span> <span class="kt">int</span> <span class="nf">hide</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cmpval</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* return that the data was not found */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cmpval</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">compare</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* move to the left */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">hide</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* move to the right */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">hide</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* mark the node as hidden */</span>
        <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">hidden</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">BiTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cmpval</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bitree_is_eob</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* return that the data was not found */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cmpval</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">compare</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* move to the left */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_left</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmpval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* move to the right */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_right</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">hidden</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* pass back the data from the tree */</span>
            <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">((</span><span class="n">AvlNode</span> <span class="o">*</span><span class="p">)</span><span class="n">bitree_data</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* return that the data was not found */</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bistree_init</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="cm">/* initialize the tree */</span>
    <span class="n">bitree_init</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">destroy</span><span class="p">);</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">compare</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bistree_destroy</span><span class="p">(</span><span class="n">Bistree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* destroy all nodes in the tree */</span>
    <span class="n">destroy_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="cm">/* no operations are allowed now, but clear the structure as a precaution */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BisTree</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bistree_insert</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">balanced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bitree_root</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">balanced</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bistree_remove</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">hide</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_root</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bistree_lookup</span><span class="p">(</span><span class="n">BisTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitree_root</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">
        <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
              <ul class="list-group" id="social">
                <li class="list-group-item"><a href="#"><i class="fa fa-you-can-add-links-in-your-config-file-square fa-lg"></i> You can add links in your config file</a></li>
                <li class="list-group-item"><a href="#"><i class="fa fa-another-social-link-square fa-lg"></i> Another social link</a></li>
              </ul>
            </li>





    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://python.org/" target="_blank">
                Python.org
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://jinja.pocoo.org/" target="_blank">
                Jinja2
            </a>
        </li>
        <li class="list-group-item">
            <a href="#" target="_blank">
                You can modify those links in your config file
            </a>
        </li>
      </ul>
    </li>
    </ul>
</section>            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2017 ivicel
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="./theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="./theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="./theme/js/respond.min.js"></script>


</body>
</html>